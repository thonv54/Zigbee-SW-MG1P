// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.



#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "stack/include/error.h"
#include "stack/include/ember-types.h"
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/serial-interface.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

// Include repair code by Thonv
#define ConfigByThonv

#include "app/framework/util/util.h"
#include "af-structs.h"
#include "call-command-handler.h"
#include "command-id.h"
#include "callback.h"

#include "device.h"
#include "halDelay.h"
#include "Uart_Transmitter.h"
#include "ZigbeeUtility.h"
#include "CommonLed.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists,
        bool mfgSpecific) {
    if (wasHandled) {
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    else if (mfgSpecific) {
        return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
    }
    else if (clusterExists) {
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    }
    else {
        return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand *cmd)
{
  if (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT
      && emberAfContainsClient(cmd->apsFrame->destinationEndpoint,
                               cmd->apsFrame->clusterId)) {
    switch (cmd->apsFrame->clusterId) {
    case ZCL_IDENTIFY_CLUSTER_ID:
      return emberAfIdentifyClusterClientCommandParse(cmd);
    }
  } else if (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER
             && emberAfContainsServer(cmd->apsFrame->destinationEndpoint,
                                      cmd->apsFrame->clusterId)) {
    switch (cmd->apsFrame->clusterId) {
    case ZCL_IDENTIFY_CLUSTER_ID:
      return emberAfIdentifyClusterServerCommandParse(cmd);
    case ZCL_GROUPS_CLUSTER_ID:
      return emberAfGroupsClusterServerCommandParse(cmd);
    case ZCL_SCENES_CLUSTER_ID:
      return emberAfScenesClusterServerCommandParse(cmd);
    case ZCL_ON_OFF_CLUSTER_ID:
      return emberAfOnOffClusterServerCommandParse(cmd);
#ifdef LEVEL_TYPE
    case ZCL_LEVEL_CONTROL_CLUSTER_ID:
        return emberAfLevelControlClusterServerCommandParse(cmd);
#endif
    }
  }
  return status(false, false, cmd->mfgSpecific);
}

// Cluster: Identify, client
EmberAfStatus emberAfIdentifyClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_IDENTIFY_QUERY_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t timeout;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        timeout = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIdentifyClusterIdentifyQueryResponseCallback(timeout);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Identify, server
EmberAfStatus emberAfIdentifyClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_IDENTIFY_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t identifyTime;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        identifyTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIdentifyClusterIdentifyCallback(identifyTime);
        break;
      }
    case ZCL_IDENTIFY_QUERY_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIdentifyClusterIdentifyQueryCallback();
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Groups, server
EmberAfStatus emberAfGroupsClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_ADD_GROUP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t* groupName;  // Ver.: always
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfGroupsClusterAddGroupCallback(groupId,
                                                          groupName);
        break;
      }
    case ZCL_VIEW_GROUP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfGroupsClusterViewGroupCallback(groupId);
        break;
      }
    case ZCL_GET_GROUP_MEMBERSHIP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t groupCount;  // Ver.: always
        uint8_t* groupList;  // Ver.: always
        // Command is fixed length: 1
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupCount = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        groupList = cmd->buffer + payloadOffset;
        wasHandled = emberAfGroupsClusterGetGroupMembershipCallback(groupCount,
                                                                    groupList);
        break;
      }
    case ZCL_REMOVE_GROUP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfGroupsClusterRemoveGroupCallback(groupId);
        break;
      }
    case ZCL_REMOVE_ALL_GROUPS_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfGroupsClusterRemoveAllGroupsCallback();
        break;
      }
    case ZCL_ADD_GROUP_IF_IDENTIFYING_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t* groupName;  // Ver.: always
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfGroupsClusterAddGroupIfIdentifyingCallback(groupId,
                                                                       groupName);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Scenes, server
EmberAfStatus emberAfScenesClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_ADD_SCENE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t sceneId;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        uint8_t* sceneName;  // Ver.: always
        uint8_t* extensionFieldSets;  // Ver.: always
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        sceneName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1;
        extensionFieldSets = cmd->buffer + payloadOffset;
        wasHandled = emberAfScenesClusterAddSceneCallback(groupId,
                                                          sceneId,
                                                          transitionTime,
                                                          sceneName,
                                                          extensionFieldSets);
        break;
      }
    case ZCL_VIEW_SCENE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t sceneId;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterViewSceneCallback(groupId,
                                                           sceneId);
        break;
      }
    case ZCL_REMOVE_SCENE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t sceneId;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterRemoveSceneCallback(groupId,
                                                             sceneId);
        break;
      }
    case ZCL_REMOVE_ALL_SCENES_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterRemoveAllScenesCallback(groupId);
        break;
      }
    case ZCL_STORE_SCENE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t sceneId;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterStoreSceneCallback(groupId,
                                                            sceneId);
        break;
      }
    case ZCL_RECALL_SCENE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        uint8_t sceneId;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterRecallSceneCallback(groupId,
                                                             sceneId);
        break;
      }
    case ZCL_GET_SCENE_MEMBERSHIP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t groupId;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfScenesClusterGetSceneMembershipCallback(groupId);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: On/off, server

#ifdef ConfigByThonv

EmberAfStatus emberAfOnOffClusterServerCommandParse(EmberAfClusterCommand *cmd) {

    boolean wasHandled = false;
    
    if (!cmd->mfgSpecific) {
        switch (cmd->commandId) {
            case ZCL_OFF_COMMAND_ID: {
                // Command is fixed length: 0
                wasHandled = emberAfOnOffClusterOffCallback();
                break;
            }
            case ZCL_ON_COMMAND_ID: {
                // Command is fixed length: 0
                wasHandled = emberAfOnOffClusterOnCallback();
                break;
            }
            case ZCL_TOGGLE_COMMAND_ID: {
                // Command is fixed length: 0
                wasHandled = emberAfOnOffClusterToggleCallback();
                break;
            }
        }
        int8u HandledStatus;
        HandledStatus = status(wasHandled, true, cmd->mfgSpecific);
        emberAfOnOffClusterServerCommandParseCallBack(HandledStatus, cmd);
    }
    return status(wasHandled, true, cmd->mfgSpecific);

#else  // end   ConfigByThonv
EmberAfStatus emberAfOnOffClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_OFF_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterOffCallback();
        break;
      }
    case ZCL_ON_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterOnCallback();
        break;
      }
    case ZCL_TOGGLE_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterToggleCallback();
        break;
      }
            }
        }
        return status(wasHandled, true, cmd->mfgSpecific);
#endif // default stack
}

#ifdef LEVEL_TYPE
#ifdef ConfigByThonv
// Cluster: Level Control, server
EmberAfStatus emberAfLevelControlClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
    
    // nhan lenh dieu khien tu HC
    ControlStateDeviceFromHCCallback();
    boolean wasHandled = FALSE;
    if (!cmd->mfgSpecific) {
        switch (cmd->commandId) {
            case ZCL_MOVE_TO_LEVEL_COMMAND_ID:
            {
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u level;  // Ver.: always
                int16u transitionTime;// Ver.: always
                // Command is fixed length: 3
                if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
#ifdef FAN
                    if(level == 0){
                        level = 0;
                    }
                    else if((level >0) && (level <= 63)){
                        level = 63;
                    }
                    else if ((level >63) && (level <= 126)){
                        level = 126;
                    }
                    else if ((level >126) && (level <= 189)){
                        level = 189;
                    }
                    else{
                        level = 255;
                    }
#endif
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterMoveToLevelCallback(level,
//                        transitionTime);
                wasHandled = true;
//--------------user controller
                //          Send to Level Change to MC
                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                break;
            }
            case ZCL_MOVE_COMMAND_ID:
            {
                int8u level;
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u moveMode;  // Ver.: always
                int8u rate;// Ver.: always
                // Command is fixed length: 2
                if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterMoveCallback(moveMode,
//                        rate);
                wasHandled = true;
//--------------user controller
                if(moveMode == EMBER_ZCL_MOVE_MODE_UP) {
                    level = 0xFF;
                }
                else {
                    level = 0x00;
                }
                                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }

                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));

                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                // end user controller

                break;
            }
            case ZCL_STEP_COMMAND_ID:
            {
                int8u level;
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u stepMode;  // Ver.: always
                int8u stepSize;// Ver.: always
                int16u transitionTime;// Ver.: always
                // Command is fixed length: 4
                if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterStepCallback(stepMode,
//                        stepSize,
//                        transitionTime);
                wasHandled = true;

                // get Current Level
                int8u currentLevel;
                emberAfReadServerAttribute(DimmerInClusterEndpoint,
                        ZCL_LEVEL_CONTROL_CLUSTER_ID,
                        ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
                        (int8u *)&currentLevel,
                        sizeof(currentLevel));
                // Get Level
                if(stepMode == EMBER_ZCL_STEP_MODE_UP) {
                    if(currentLevel + stepSize > EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL) {
                        level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL;
                    }
                    else {
                        level = currentLevel + stepSize;
                    }
                }
                else {
                    if(currentLevel - stepSize < EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL) {
                        level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL;
                    }
                    else {
                        level = currentLevel - stepSize;
                    }
                }
                // Send to Level Change to MC
                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                // end user controller
                
                break;
            }
            case ZCL_STOP_COMMAND_ID:
            {
                // Command is fixed length: 0
                wasHandled = emberAfLevelControlClusterStopCallback();
                // get Current Level
                int8u currentLevel;
                emberAfReadServerAttribute(DimmerInClusterEndpoint,
                        ZCL_LEVEL_CONTROL_CLUSTER_ID,
                        ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
                        (int8u *)&currentLevel,
                        sizeof(currentLevel));
  
                // Send to Level Change to MC
                int8u OnOffState;
                if (currentLevel != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);
#ifdef CURTAIN
                UartSendCurtainStop(DeviceNo);
#else
                UartSendLevel(DeviceNo,currentLevel);
#endif

                // end user controller
                break;
            }
            case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID:
            {
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u level;  // Ver.: always
                int16u transitionTime;// Ver.: always
                // Command is fixed length: 3
                if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level,
//                        transitionTime);
                wasHandled = true;
                // user controller
                // Send to Level Change to MC
                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                // End user controller
                break;
            }
            case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID:
            {
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u moveMode;  // Ver.: always
                int8u rate;// Ver.: always
                // Command is fixed length: 2
                if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterMoveWithOnOffCallback(moveMode,
//                        rate);
                wasHandled = true;
                // user controller
                
                int8u level;
                if(moveMode == EMBER_ZCL_MOVE_MODE_UP) {
                    level = 0xFF;
                }
                else {
                    level = 0x00;
                }
                
                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                // end user controller
                break;
            }
            case ZCL_STEP_WITH_ON_OFF_COMMAND_ID:
            {
                int16u payloadOffset = cmd->payloadStartIndex;
                int8u stepMode;  // Ver.: always
                int8u stepSize;// Ver.: always
                int16u transitionTime;// Ver.: always
                // Command is fixed length: 4
                if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
//                wasHandled = emberAfLevelControlClusterStepWithOnOffCallback(stepMode,
//                        stepSize,
//                        transitionTime);
                wasHandled = true;
                //      user controller
                int8u level;
                //      get Current Level
                int8u currentLevel;
                emberAfReadServerAttribute(DimmerInClusterEndpoint,
                        ZCL_LEVEL_CONTROL_CLUSTER_ID,
                        ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
                        (int8u *)&currentLevel,
                        sizeof(currentLevel));
                //      Get Level
                if(stepMode == EMBER_ZCL_STEP_MODE_UP) {
                    if(currentLevel + stepSize > EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL) {
                        level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL;
                    }
                    else {
                        level = currentLevel + stepSize;
                    }
                }
                else {
                    if(currentLevel - stepSize < EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL) {
                        level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL;
                    }
                    else {
                        level = currentLevel - stepSize;
                    }
                }
                // Send to Level Change to MC
                int8u OnOffState;
                if (level != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,level);
                // end user controller
                break;
            }
            case ZCL_STOP_WITH_ON_OFF_COMMAND_ID:
            {
                // Command is fixed length: 0
                wasHandled = emberAfLevelControlClusterStopWithOnOffCallback();
                //user control
                //get Current Level
                int8u currentLevel;
                emberAfReadServerAttribute(DimmerInClusterEndpoint,
                        ZCL_LEVEL_CONTROL_CLUSTER_ID,
                        ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
                        (int8u *)&currentLevel,
                        sizeof(currentLevel));
                // Send to Level Change to MC
                int8u OnOffState;
                if (currentLevel != 0){
                    OnOffState = 1;
                }
                else{
                    OnOffState = 0;
                }
                
                emberAfWriteServerAttribute(cmd->apsFrame->destinationEndpoint,
                        ZCL_ON_OFF_CLUSTER_ID,
                        ZCL_ON_OFF_ATTRIBUTE_ID,
                        &OnOffState,
                        sizeof (OnOffState));
                int8u DeviceNo =   ((cmd->apsFrame->destinationEndpoint >> 1)+1);  
                UartSendLevel(DeviceNo,currentLevel);
                // end user controller
                break;
            }
        }
    }
    return status(wasHandled,true, cmd->mfgSpecific);
}

#else 
EmberAfStatus emberAfLevelControlClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific) {
        switch (cmd->commandId) {
            case ZCL_MOVE_TO_LEVEL_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t level;  // Ver.: always
                uint16_t transitionTime;// Ver.: always
                // Command is fixed length: 3
                if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterMoveToLevelCallback(level,
                        transitionTime);
                break;
            }
            case ZCL_MOVE_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t moveMode;  // Ver.: always
                uint8_t rate;// Ver.: always
                // Command is fixed length: 2
                if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterMoveCallback(moveMode,
                        rate);
                break;
            }
            case ZCL_STEP_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t stepMode;  // Ver.: always
                uint8_t stepSize;// Ver.: always
                uint16_t transitionTime;// Ver.: always
                // Command is fixed length: 4
                if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterStepCallback(stepMode,
                        stepSize,
                        transitionTime);
                break;
            }
            case ZCL_STOP_COMMAND_ID:
            {
                // Command is fixed length: 0
                wasHandled = emberAfLevelControlClusterStopCallback();
                break;
            }
            case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t level;  // Ver.: always
                uint16_t transitionTime;// Ver.: always
                // Command is fixed length: 3
                if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level,
                        transitionTime);
                break;
            }
            case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t moveMode;  // Ver.: always
                uint8_t rate;// Ver.: always
                // Command is fixed length: 2
                if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterMoveWithOnOffCallback(moveMode,
                        rate);
                break;
            }
            case ZCL_STEP_WITH_ON_OFF_COMMAND_ID:
            {
                uint16_t payloadOffset = cmd->payloadStartIndex;
                uint8_t stepMode;  // Ver.: always
                uint8_t stepSize;// Ver.: always
                uint16_t transitionTime;// Ver.: always
                // Command is fixed length: 4
                if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
                stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1;
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
                wasHandled = emberAfLevelControlClusterStepWithOnOffCallback(stepMode,
                        stepSize,
                        transitionTime);
                break;
            }
            case ZCL_STOP_WITH_ON_OFF_COMMAND_ID:
            {
                // Command is fixed length: 0
                wasHandled = emberAfLevelControlClusterStopWithOnOffCallback();
                break;
            }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

#endif
#endif

